<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Theobald.Common</name>
    </assembly>
    <members>
        <member name="T:Theobald.Common.AsyncCountdown">
            <summary>
            Assumption: No increments after zero has been reached.
            This can be used to count things, then stop creating new things
            and wait until all things are gone.
            </summary>
        </member>
        <member name="M:Theobald.Common.Csv.CsvFormatException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Theobald.Common.Csv.CsvFormatException"/> class.
            </summary>
        </member>
        <member name="M:Theobald.Common.Csv.CsvFormatException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Theobald.Common.Csv.CsvFormatException"/> class with a specified message.
            </summary>
        </member>
        <member name="M:Theobald.Common.Csv.CsvFormatException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Theobald.Common.Csv.CsvFormatException"/> class with a specified error message
            and a reference to the inner exception that is teh cause of this exception.
            </summary>
        </member>
        <member name="T:Theobald.Common.Csv.CsvLineReader">
            <summary>
            Wraps a CsvReader and a StreamReader for more convenient access to each Line of a Csv stream.
            </summary>
        </member>
        <member name="M:Theobald.Common.Csv.CsvLineReader.#ctor(System.Char,System.Int32)">
            <summary>Creates a CsvLineReader using the default Row Separator CrLf.</summary>
            <param name="columnSeparator">Column Separator character.</param>
            <param name="expectedCellCount">Expected number of Cells each row (used as Capacity for the internal list).</param>
        </member>
        <member name="M:Theobald.Common.Csv.CsvLineReader.#ctor(System.Char,System.Char,System.Int32)">
            <summary>Creates a CsvLineReader with a custom row separator character.</summary>
            <param name="columnSeparator">Column separator character.</param>
            <param name="rowSeparator">Row separator character.</param>
            <param name="expectedCellCount">Expected number of Cells each row (used as Capacity for the internal list).</param>
        </member>
        <member name="M:Theobald.Common.Csv.CsvLineReader.Lines">
            <summary>Returns an enumerable of strings for each completely read Line in the CSV data stream.</summary>
            <remarks>
            You must immediately consume/store the return value of this method. The underlying collection will
            be cleared when advancing the reader.
            </remarks>
        </member>
        <member name="T:Theobald.Common.Csv.CsvReaderState">
            <summary>
            States for the CsvReader
            </summary>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReaderState.Line">
            <summary>
            Normal reading state
            </summary>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReaderState.NewLine">
            <summary>
            The cell loaded into the Current property marks the beginning of a new row.
            Hence it is the first cell of the new row.
            </summary>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReaderState.NeedsData">
            <summary>
            The reader is waiting for more data to be supplied via the Feed() method.
            </summary>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReaderState.Error">
            <summary>
            Non recoverable error. Check the exception thrown with this for more information.
            </summary>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReaderState.EndOfData">
            <summary>
            The reader is closed since the CSV data was read completely.
            This state is hit when the reader runs into MoreData AFTER the Finalize() method was called.
            </summary>
        </member>
        <member name="T:Theobald.Common.Csv.CsvReader">
             <summary>
                 Reads the characters provided via Feed() and assembles data from CSV following RFC4180.
             </summary>
             <example>
                 <code>
             CsvReader reader = new CsvReader(',');
             byte[] buffer;
             while (dataAvailable)
             {
                 switch (reader.State)
                 {
                     case CsvReaderState.Line:
                         HandleCell(reader.Current.Value);
                         break;
                     case CsvReaderState.NewLine:
                         HandleLineBreak();
                         HandleCell(reader.Current.Value);
                         break;
                     case CsvReaderState.NeedsData:
                         int bytesRead = await stream.ReadAsync(buffer);
                         if (0 == bytesRead)
                         {
                             reader.FinalizeReader();
                         }
                         else
                         {
                             reader.Feed(new ArraySegment&lt;byte&gt;(buffer, 0, bytesRead));
                         }
                         break;
                     case CsvReaderState.EndOfData:
                         dataAvailable = false;
                         break;
                     default:
                         throw new InvalidOperationException();
                 }
            
                 reader.MoveNext();
             }
             </code>
             </example>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReader.empty">
            <summary>
                Static empty array segment to reference for performance optimization.
            </summary>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReader.firstLine">
            <summary>
                Marks the first line ever read by this reader. Used to count columns and know when to signal a line break.
            </summary>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReader.lastTokenIsQuote">
            <summary>
            </summary>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReader.columnCount">
            <summary>
                The number of columns in the CSV
                Gets increased until the first line break is read.
            </summary>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReader.columnPointer">
            <summary>
                Holds the index of the current column when moving over the cells via MoveNext().
                If it gets the same value as columnCount, we signal a line break.
            </summary>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReader.cells">
            <summary>
                Holds the cells, which were read from the segment.
                It is used as a FiFo structure.
                MoveNext() always pulls out the first item.
            </summary>
        </member>
        <member name="F:Theobald.Common.Csv.CsvReader.previousState">
            <summary>
                indicates whether to ignore empty cells from the cell reader,
                which occur when transitioning between quote and non quote
            </summary>
        </member>
        <member name="P:Theobald.Common.Csv.CsvReader.State">
            <summary>
                Indicates if Current marks the first item of a new line.
                For the first line, this is always false.
            </summary>
        </member>
        <member name="P:Theobald.Common.Csv.CsvReader.Current">
            <summary>
                Holds the current item loaded through calling MoveNext()
                or null if all cells where read/ no cells where read yet.
            </summary>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.#ctor(System.Char)">
            <summary>
                Creates a new instance of the new <see cref="T:Theobald.Common.Csv.CsvReader" /> class with the given delimiter.
                The row delimiter is CrLf.
            </summary>
            <param name="delimiter">specifies how columns are delimited</param>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.#ctor(System.Char,System.Char)">
            <summary>
                Creates a new instance of the new <see cref="T:Theobald.Common.Csv.CsvReader" /> class with the given delimiter.
            </summary>
            <param name="columnDelimiter">specifies how columns are delimited</param>
            <param name="rowDelimiter">specifies how rows are delimited</param>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.Feed(System.ArraySegment{System.Char})">
            <summary>
                (Re)fills the reader with the next chunk of data to parse.
            </summary>
            <param name="data"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.Feed(System.ArraySegment{System.Byte})">
            <summary>
                (Re)fills the reader with the next chunk of data to parse.
            </summary>
            <param name="data"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.MoveNext">
            <summary>
                Checks if there is a cell to move into the Current property.
                If not, the parser is reading more of the data if available and
                then checks again if cells can be assembled.
            </summary>
            <returns>true if there is a next cell available, false otherwise.</returns>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.CheckCells">
            <summary>
                Returns whether cells are available for the user to process.
                NewLine is assigned whether the reader passed a line break, when
                moving to the next cell.
            </summary>
            <returns>true if a cell was loaded, falls otherwise.</returns>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.FinalizeReader">
            <summary>
                Call this method if there is no data left to be filled into the reader.
                It empties the buffer and assumes that all data was passed through the reader,
                thus the cells being complete.
            </summary>
            <returns>the cells for the last line or the last quoted cell.</returns>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.ProcessNonQuote(System.Boolean)">
            <summary>
                Handle the cases and circumstances under which a NonQuote token
                might be read.
            </summary>
            <param name="nonQuoteEnd"></param>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.ProcessLines(System.Collections.Generic.IList{System.ArraySegment{System.Char}})">
             <summary>
            
             </summary>
             <param name="lines"></param>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.Parse">
            <summary>
                Parsing the data into quoted and not quoted sections.
            </summary>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.AddCell(System.ArraySegment{System.Char})">
            <summary>
            </summary>
            <param name="cell"></param>
        </member>
        <member name="M:Theobald.Common.Csv.CsvReader.AddCells(System.Collections.Generic.IList{System.ArraySegment{System.Char}})">
            <summary>
                We have to copy the cells to a new array to avoid overwriting old ones.
            </summary>
            <param name="newCells"></param>
        </member>
        <member name="M:Theobald.Common.Encoding.BytesToChars.Decode(System.ArraySegment{System.Byte})">
            <summary>
            Consumes all the <paramref name="bytes"/> and decodes them into <see cref="T:System.Char"/>s
            </summary>
        </member>
        <member name="P:Theobald.Common.Encoding.BytesToLines.Cr">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Encoding.BytesToLines.Lf">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Encoding.BytesToLines.TokenSize">
            <inheritdoc />
        </member>
        <member name="M:Theobald.Common.Encoding.CharsToLines.#ctor(System.Char)">
            <summary>
            If this ctor is used the <see cref="P:Theobald.Common.Encoding.CharsToLines.Lf"/> property is overwritten to use a single token as a row delimiter
            </summary>
            <param name="rowDelimiter"></param>
        </member>
        <member name="P:Theobald.Common.Encoding.CharsToLines.Cr">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Encoding.CharsToLines.Lf">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Encoding.CharsToLines.TokenSize">
            <inheritdoc />
        </member>
        <member name="T:Theobald.Common.Encoding.CharsToQuotes">
            <summary>
            Runs over an <see cref="T:System.ArraySegment`1"/> and exposes a state to show whether
            the reader is currently in a quote area or not.
            </summary>
        </member>
        <member name="M:Theobald.Common.Encoding.DataToLines`1.SplitCrLf(System.ArraySegment{`0})">
            <summary>
            Splits the <paramref name="segment"/> into sub-segments at CRLF newline.
            <remarks>
                The CRLFs are not part of the sub-segments.
                Chars at the end of the segment, that are not followed by a CRLF, are stored in an
                internal buffer and added to the first line of the next call.
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Common.Encoding.DataToLines`1.Flush">
            <summary>
            Returns the saved characters that didn't make a full line yet.
            <remarks>This might be useful, if the last line is not followed by a newline</remarks>
            </summary>
        </member>
        <member name="M:Theobald.Common.Encoding.DataToLines`1.GetRemaining">
            <summary>
            Return the unprocessed data regardless of its potential line breaks.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Theobald.Common.Encoding.Gb18030NoPreamble">
            <summary>
            In a nutshell, it is the Chinese version of UTF-8
            </summary>
        </member>
        <member name="T:Theobald.Common.Encoding.Gb18030WithPreamble">
            <summary>
            In a nutshell, it is the Chinese version of UTF-8
            </summary>
        </member>
        <member name="T:Theobald.Common.Encoding.LineToCells">
            <summary>
            Takes an <see cref="T:System.ArraySegment`1"/> and splits it into cells using the specified delimiter.
            </summary>
        </member>
        <member name="M:Theobald.Common.Encoding.LineToCells.SplitDelimiter(System.ArraySegment{System.Char},System.Char)">
            <summary>
            Splits the line into <see cref="T:System.ArraySegment`1"/>s representing the array of cells within that line.
            </summary>
            <param name="line"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="T:Theobald.Common.Encoding.LittleEndianBase128">
            <summary>
            Variable-length encoding for integers.
            https://en.wikipedia.org/wiki/LEB128
            </summary>
        </member>
        <member name="T:Theobald.Common.Fnv1aHash32">
            <summary>
            Gets the Fowler–Noll–Vo FNV-1a 32 bits hash of a string.
            Can be used as a checksum, or to significantly reduce
            the probability of collisions when shortening strings.
            <remarks>
            Homepage of Landon Curt Noll, the 'N' in FNV:
            http://www.isthe.com/chongo/tech/comp/fnv/index.html
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Common.Fnv1aHash32.CalculateAsync(System.Func{System.Threading.Tasks.Task{System.ArraySegment{System.Byte}}})">
            <summary>
            Gets the Fowler–Noll–Vo FNV-1a hash of a series of data chunks.
            </summary>
            <param name="readAsync">
                Reads next chunk of input data. This func is called until it returns a
                segment with 0 length.
                <remarks>
                    It is required that the segment of the previous read is still valid
                    while the current read is in progress, until the next read begins.
                    I. e. you could provide e. g. a func that uses two alternating buffers.
                </remarks>
            </param>
            <returns></returns>
        </member>
        <member name="M:Theobald.Common.Fnv1aHash32.CalculateAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Gets the Fowler–Noll–Vo FNV-1a hash of a stream asynchronously. 
            </summary>
        </member>
        <member name="M:Theobald.Common.Fnv1aHash32.Calculate(System.IO.Stream@)">
            <summary>
            Gets the Fowler–Noll–Vo FNV-1a hash of a stream. 
            </summary>
        </member>
        <member name="M:Theobald.Common.Fnv1aHash32.Calculate(System.String@)">
            <summary>
            Gets the Fowler–Noll–Vo FNV-1a hash of a string. 
            </summary>
        </member>
        <member name="T:Theobald.Common.Fnv1aHash64">
            <summary>
            Gets the Fowler–Noll–Vo FNV-1a 64 bits hash of a string.
            Can be used as a checksum, or to significantly reduce
            the probability of collisions when shortening strings.
            <remarks>
            Homepage of Landon Curt Noll, the 'N' in FNV:
            http://www.isthe.com/chongo/tech/comp/fnv/index.html
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Common.Fnv1aHash64.CalculateAsync(System.Func{System.Threading.Tasks.Task{System.ArraySegment{System.Byte}}})">
            <summary>
            Gets the Fowler–Noll–Vo FNV-1a hash of a series of data chunks.
            </summary>
            <param name="readAsync">
                Reads next chunk of input data. This func is called until it returns a
                segment with 0 length.
                <remarks>
                    It is required that the segment of the previous read is still valid
                    while the current read is in progress, until the next read begins.
                    I. e. you could provide e. g. a func that uses two alternating buffers.
                </remarks>
            </param>
            <returns></returns>
        </member>
        <member name="M:Theobald.Common.Fnv1aHash64.CalculateAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Gets the Fowler–Noll–Vo FNV-1a hash of a stream asynchronously. 
            </summary>
        </member>
        <member name="M:Theobald.Common.Fnv1aHash64.Calculate(System.IO.Stream@)">
            <summary>
            Gets the Fowler–Noll–Vo FNV-1a hash of a stream. 
            </summary>
        </member>
        <member name="M:Theobald.Common.Fnv1aHash64.Calculate(System.String@)">
            <summary>
            Gets the Fowler–Noll–Vo FNV-1a hash of a string. 
            </summary>
        </member>
        <member name="T:Theobald.Common.IoHelper">
            <remarks>
            The retry methods should only be used in scenarios with low collision probability,
            because they can starve. Please use a starving-free synchronization mechanism
            like <see cref="T:System.Threading.Mutex" /> if collisions are likely.
            </remarks>
        </member>
        <member name="F:Theobald.Common.IoHelper.IoError.SharingViolation">
            <summary>
            ERROR_SHARING_VIOLATION ("Used by another process.")
            </summary>
        </member>
        <member name="F:Theobald.Common.IoHelper.IoError.FileExists">
            <summary>
            ERROR_FILE_EXISTS ("The file exists.")
            </summary>
        </member>
        <member name="M:Theobald.Common.IoHelper.DeleteFileRetry(System.String)">
            <summary>
            Tries to delete a file. 
            If the file is currently in use, waits and retries a few times
            (deleting files on Windows is not atomic).
            </summary>
        </member>
        <member name="M:Theobald.Common.IoHelper.OpenFileRetryWriteAsync(System.String,System.IO.FileMode,System.IO.FileShare,System.Threading.CancellationToken)">
            <summary>
            Tries to open a file for writing.
            If the file is currently in use, waits and retries a few times.
            Creates all directories and subdirectories in the specified path
            unless they already exist or the <paramref name="fileMode"/> expects the file to exist.
            </summary>
            <remarks>
            The file could be in use because it is currently being deleted.
            It is currently unknown what happens, when directories of the path are being
            created/deleted in parallel.
            </remarks>
            <exception cref="T:Theobald.Common.FileExistsException"/>
        </member>
        <member name="M:Theobald.Common.IoHelper.OpenFileRetryReadAsync(System.String,System.IO.FileShare,System.Threading.CancellationToken)">
            <summary>
            Tries to open a file for reading.
            If the file is currently in use, waits and retries a few times.
            <see cref="T:System.IO.FileNotFoundException"/> exception is thrown if the file does not exist.
            </summary>
        </member>
        <member name="M:Theobald.Common.IoHelper.GetHResult(System.IO.IOException)">
            <summary>
            Gets the HRESULT in .NET Framework versions before 4.5
            </summary>
        </member>
        <member name="M:Theobald.Common.IoHelper.OpenFileRetryRead(System.String,System.IO.FileShare)">
            <summary>
            Tries to open a file for reading.
            If the file is currently in use, waits and retries a few times.
            <see cref="T:System.IO.FileNotFoundException"/> exception is thrown if the file does not exist.
            </summary>
        </member>
        <member name="M:Theobald.Common.IoHelper.OpenOrCreateFileRetryReadWrite(System.String)">
            <summary>
            Tries to open a file for reading and writing.
            If the file is currently in use, waits and retries a few times.
            If the file does not exist it will be created.
            </summary>
        </member>
        <member name="M:Theobald.Common.IoHelper.OpenFileRetryAppend(System.String,System.IO.FileShare)">
            <summary>
            Tries to open a file for appending.
            If the file is currently in use, waits and retries a few times.
            Creates all directories and subdirectories in the specified path
            unless they already exist.
            </summary>
            <remarks>
            It is currently unknown what happens, when directories of the path are being
            created/deleted in parallel.
            </remarks>
        </member>
        <member name="M:Theobald.Common.IoHelper.OpenFileRetryWrite(System.String,System.IO.FileMode,System.IO.FileShare)">
            <summary>
            Tries to open a file for writing.
            If the file is currently in use, waits and retries a few times.
            Creates all directories and subdirectories in the specified path
            unless they already exist or the <paramref name="fileMode"/> expects the file to exist.
            </summary>
            <remarks>
            The file could be in use because it is currently being deleted.
            It is currently unknown what happens, when directories of the path are being
            created/deleted in parallel.
            </remarks>
            <exception cref="T:Theobald.Common.FileExistsException"/>
        </member>
        <member name="T:Theobald.Common.NamedList`1">
            <summary>
            Represents a generic list of named elements,
            which can be accessed by name or by index
            </summary>
        </member>
        <member name="T:Theobald.Common.Number">
            <summary>
            A struct that can represent any number the .NET
            environment can naturally deal with. It juggles
            with <see cref="T:System.Decimal" /> and <see cref="T:System.Double" />
            and provides implicit conversions for some other
            numeric types.
            </summary>
        </member>
        <member name="T:Theobald.Common.Security.CertificatePinningState">
            <summary>
            Applies certificate pinning with the supplied public key information.
            If the public key information is null or empty, the first publicKeyInformation available is pinned
            and used for subsequent validations.
            It can be extracted afterwards.
            </summary>
        </member>
        <member name="P:Theobald.Common.Security.CertificatePinningState.PinnedPublicKeyInformation">
            <summary>
            Holds the public key information of the pinned key.
            </summary>
        </member>
        <member name="M:Theobald.Common.Security.CertificatePinningState.#ctor(System.String)">
            <summary>
            Create a new configuration for a SecureNetworkingFactory object, with the default certificate pinning
            logic, respecting the given public key information.
            </summary>
            <param name="pinnedPublicKeyInformation"></param>
        </member>
        <member name="M:Theobald.Common.Security.CertificatePinningState.BuildCallback">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Theobald.Common.Security.HttpsWebRequest">
            <summary>
            This is a wrapper class to make the error handling easier for the user.
            The inheritance is only here to keep the interface intact.
            All methods and properties are relayed to the internal HttpWebRequest object.
            </summary>
        </member>
        <member name="P:Theobald.Common.Security.HttpsWebRequest.ServerCertificateValidationCallback">
            <summary>Gets or sets a callback function to validate the server certificate.</summary>
            <returns>A callback function to validate the server certificate.</returns>
        </member>
        <member name="P:Theobald.Common.Security.HttpsWebRequest.Method">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Security.HttpsWebRequest.Headers">
            <inheritdoc />
        </member>
        <member name="M:Theobald.Common.Security.HttpsWebRequest.Abort">
            <inheritdoc />
        </member>
        <member name="M:Theobald.Common.Security.HttpsWebRequest.GetRequestStream">
            <inheritdoc />
        </member>
        <member name="M:Theobald.Common.Security.HttpsWebRequest.GetRequestStreamAsync">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Security.HttpsWebRequest.CachePolicy">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Security.HttpsWebRequest.ConnectionGroupName">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Security.HttpsWebRequest.ContentLength">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Security.HttpsWebRequest.ContentType">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Security.HttpsWebRequest.RequestUri">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Security.HttpsWebRequest.Timeout">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Security.HttpsWebRequest.UseDefaultCredentials">
            <inheritdoc />
        </member>
        <member name="M:Theobald.Common.Security.HttpsWebRequest.InitializeLifetimeService">
            <inheritdoc />
        </member>
        <member name="P:Theobald.Common.Security.HttpsWebRequest.Credentials">
            <inheritdoc />
        </member>
        <member name="M:Theobald.Common.Security.HttpsWebRequest.GetResponse">
            <inheritdoc />
        </member>
        <member name="M:Theobald.Common.Security.HttpsWebRequest.GetResponseAsync">
            <inheritdoc />
        </member>
        <member name="T:Theobald.Common.Security.Pbkdf2Hash">
            <summary>
            Simple class that provides utility to create pbkdf2 hashes.
            </summary>
        </member>
        <member name="M:Theobald.Common.Security.Pbkdf2Hash.Compute(System.String,System.Byte[])">
            <summary>
            Gets a 32 byte long salted hash for a <see cref="T:System.String"/> using pbkdf2 with 10000 iterations.
            </summary>
            <param name="key">The string to hash.</param>
            <param name="salt">The salt for additional security. Has to be at least eight bytes in length.</param>
            <returns>An array of 32 bytes that represent the hash.</returns>
        </member>
        <member name="M:Theobald.Common.Security.Pbkdf2Hash.Compute(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Gets a salted hash for a <see cref="T:System.String"/> using pbkdf2.
            </summary>
            <param name="key">The string to hash.</param>
            <param name="salt">The salt for additional security. Has to be at least eight bytes in length.</param>
            <param name="length">The length of the hash to compute.</param>
            <param name="iterations">The iteration count for the algorithm.</param>
            <returns>An array of bytes that represent the hash.</returns>
        </member>
        <member name="M:Theobald.Common.Security.SecureNetworkingFactory.NewSslStream(Theobald.Common.Security.TlsState,System.IO.Stream,System.Boolean,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)">
            <summary>
            
            </summary>
            <param name="config"></param>
            <param name="innerStream"></param>
            <param name="leaveInnerStreamOpen"></param>
            <param name="selectionCallback"></param>
            <param name="encryptionPolicy"></param>
            <returns></returns>
        </member>
        <member name="M:Theobald.Common.Security.SecureNetworkingFactory.NewHttpsWebRequest(Theobald.Common.Security.TlsState,System.Uri,Theobald.Common.Http.HttpMethod)">
            <summary>
            Creates a new HttpWebRequest object with the given uri and method.
            The instance has a custom certificate validation callback attached, which provides better
            error message and custom logic, which is taken from the Config property.
            </summary>
            <param name="config"></param>
            <param name="uri"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Theobald.Common.Security.SecureNetworkingFactory.TrySanitizeCertificateValidationError(System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,System.String@)">
            <summary>
            We have to write the better message to the config object, because the ssl stream expects a return value.
            If we would fail up the stack, weird behavior happens.
            </summary>
            <param name="chain"></param>
            <param name="errors"></param>
            <param name="message"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:Theobald.Common.Security.TlsState">
             <summary>
             Default class for creating instances of HttpWebRequest and SslStream.
             It only holds the state information and is a blueprint for inheritance.
            
             Call config.ThrowOnValidationError in the catch block of your code to get an authentication exception with the
             improved error message.
             </summary>
        </member>
        <member name="P:Theobald.Common.Security.TlsState.ErrorMessage">
            <summary>
            The first error message which was emitted in the validation process.
            The validation fails after the first error, so there never is more than one error (message).
            </summary>
        </member>
        <member name="P:Theobald.Common.Security.TlsState.ConnectionState">
            <summary>
            The state, the connection was in after the validation callback executed.
            </summary>
        </member>
        <member name="M:Theobald.Common.Security.TlsState.ThrowOnValidationFailureWithInner(System.Exception)">
            <summary>
            Throws an appropriate exception if the certificate validation failed.
            </summary>
            <param name="inner">The exception is attached to the new exception as its inner exception</param>
            <exception cref="T:System.Security.Authentication.AuthenticationException"></exception>
        </member>
        <member name="T:Theobald.Common.Security.TlsConnectionState">
            <summary>
            The state of the validation. Set this in your custom callback to be correctly handled
            by the ThrowOnValidationError methods.
            </summary>
        </member>
        <member name="T:Theobald.Common.StringFilter">
            <summary>
            Specialized class for filtering string contents.
            <remarks>
                This is especially useful for large amounts of data,
                e. g. CSV destination in XU.
                Nobody ran any performance tests yet to check,
                if this implementation beats compiled Regex.
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Common.StringHelper.TrimEndSpace(System.String)">
            <summary>
            Specialized method for removing spaces from the end of a string
            </summary>
            <param name="value">string to remove spaces from</param>
            <returns>s with spaces removed at the end</returns>
        </member>
        <member name="M:Theobald.Common.StringHelper.TrimNull(System.String)">
            <summary>
            Trims spaces at
            beginning and end, and replaces empty strings
            (before and after trimming) with nulls
            </summary>
        </member>
        <member name="M:Theobald.Common.StringHelper.ToUpperTrimNull(System.String)">
            <summary>
            Converts a string to uppercase, trims spaces at
            beginning and end, and replaces empty strings
            (before and after trimming) with nulls
            </summary>
        </member>
        <member name="M:Theobald.Common.StringHelper.ParseHexString(System.String,System.Byte[],System.Int32)">
            <summary>
            Converts a string of hex specifiers to a byte array.
            Two characters make up one byte, not case-sensitive. 
            Strings with odd numbers of characters are zero-padded at the beginning.
            Examples:
                "AFFE" -> { 0xaf, 0xfe}
                "2342" -> { 0x23, 0x42 }  
                "1eee7" -> { 0x01, 0xee, 0xe7 }
            </summary>
            <remarks>
            Reading table QSENDDEST on older systems might return a hex string with
            an odd number of characters.
            </remarks>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Theobald.Common.StringHelper.ParseHexString(System.String)">
            <summary>
            Converts a string of hex specifiers to a byte array.
            Two characters make up one byte, not case-sensitive. 
            Strings with odd numbers of characters are zero-padded at the beginning.
            Examples:
                "AFFE" -> { 0xaf, 0xfe}
                "2342" -> { 0x23, 0x42 }  
                "1eee7" -> { 0x01, 0xee, 0xe7 }
            </summary>
            <remarks>
            Reading table QSENDDEST on older systems might return a hex string with
            an odd number of characters.
            </remarks>
        </member>
        <member name="M:Theobald.Common.StringHelper.ToHexAscii(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts a byte array to a ASCII codepoints of hex specifiers.
            A-F symbols are uppercase.
            Examples:
                { 0xaf, 0xfe} -> { 0x41, 0x46, 0x46, 0x45 }
                { 0x23, 0x42 }  -> { 0x32, 0x33, 0x34, 0x32 }
                { 0x1e, 0xee, 0x70 } -> { 0x31, 0x45, 0x45, 0x45, 0x37, 0x30 }
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Theobald.Common.StringHelper.ToHexString(System.Byte[])">
            <summary>
            Converts a byte array to a string of hex specifiers.
            A-F symbols are uppercase.
            Examples:
                { 0xaf, 0xfe} -> "AFFE"
                { 0x23, 0x42 }  -> "2342"
                { 0x1e, 0xee, 0x70 } ->  "1EEE70"
            </summary>
        </member>
        <member name="M:Theobald.Common.StringHelper.ToIso8601Duration(System.TimeSpan@)">
            <summary>
            Returns the string ISO8601 representation of a given TimeSpan
            </summary>
            <remarks>
            ISO8601: "PT{0:00}H{1:00}M{2:00}.{3:000}S"
            </remarks>
            <param name="timeSpanValue">TimeSpan used to return the string</param>
            TotalHours cannot be passed directly, for it 
            is rounded up by string.Format, which causes an addition
            of an extra hour to the TimeSpan parsed value.
            For example, if the TimeSpan has a value of 
            30 minutes, the property TotalHours will return the fraction of 
            hours for it, which will be 0.5, that will be rounded to 1, making
            the parsed TimeSpan PT01H30M.000 instead of PT00H30M.000
            TimeSpan.Hour does not fit also, because it ranges only
            between -23 and 23 hours and it must be possible
            to display over 24 hours execution time
        </member>
        <member name="T:Theobald.Common.TheoVersionHistory">
            <summary>
            Version history.
            </summary>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoBuild.ToString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation and appends the branch name.
            </summary>
            <param name="branchName">Branch name to append</param>
            <returns>The string representation containing the branch name.</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoBuild.TryParse(System.String,Theobald.Common.VersionHistory.TheoBuild@)">
            <summary>
             Tries to convert the string representation of a build number
             to its TheoBuild equivalent
            </summary>
            <param name="value">The string representation</param>
            <param name="build">The converted TheoBuild</param>
            <returns>True if the conbuild succeeded; false otherwise</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoBuild.Compare(Theobald.Common.VersionHistory.TheoBuild,Theobald.Common.VersionHistory.TheoBuild)">
            <summary>
            Compares two specified TheoBuild objects and returns an integer that
            indicates their relationship to one another in the sort order.
            </summary>
            <param name="buildA">The first TheoBuild object</param>
            <param name="buildB">The second TheoBuild object</param>
            <returns>A 32-bit signed integer indicating the temporal relationship between the two comparands.
            Less than zero: buildA is older than buildB.
            Zero: buildA equals buildB. 
            Greater than zero: buildA is newer than buildB.</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoBuild.CompareTo(Theobald.Common.VersionHistory.TheoBuild)">
            <summary>
            Compares this instance to the specified TheoBuild object and returns an integer that
            indicates their relationship to one another in the sort order.
            </summary>
            <param name="other">The build to compare with this instance</param>
            <returns>A 32-bit signed integer indicating the temporal relationship between the two comparands.
            Less than zero: this instance is older than the other.
            Zero: this instance equals the other. 
            Greater than zero: this instance is newer than the other</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoBuild.Equals(System.Object)">
            <summary>
            Determines whether this instance is equal to the specified System.Object
            </summary>
            <param name="obj">The System.Object to compare with this instance</param>
            <returns>True if this instance is equal to the specified System.Object; false otherwise</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoBuild.GetHashCode">
            <summary>
            Returns the hash code for this instance
            </summary>
            <returns>A 32-bit signed integer hash code</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoBuild.op_Equality(Theobald.Common.VersionHistory.TheoBuild,Theobald.Common.VersionHistory.TheoBuild)">
            <summary>
            Determines if two builds are equal
            </summary>
            <param name="buildA">The first build</param>
            <param name="buildB">The second build</param>
            <returns>True if the specified builds are equal; false otherwise</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoBuild.op_Inequality(Theobald.Common.VersionHistory.TheoBuild,Theobald.Common.VersionHistory.TheoBuild)">
            <summary>
            Determines if two builds are not equal
            </summary>
            <param name="buildA">The first build</param>
            <param name="buildB">The second build</param>
            <returns>True if the specified builds are not equal; false otherwise</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoBuild.op_LessThan(Theobald.Common.VersionHistory.TheoBuild,Theobald.Common.VersionHistory.TheoBuild)">
            <summary>
            Determines if one build is newer than another build
            </summary>
            <param name="buildA">The first build</param>
            <param name="buildB">The second build</param>
            <returns>True if the first build is newer than the second build; false otherwise</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoBuild.op_GreaterThan(Theobald.Common.VersionHistory.TheoBuild,Theobald.Common.VersionHistory.TheoBuild)">
            <summary>
            Determines if one build is older than another build
            </summary>
            <param name="buildA">The first build</param>
            <param name="buildB">The second build</param>
            <returns>True if the first build is older than the second build; false otherwise</returns>
        </member>
        <member name="T:Theobald.Common.VersionHistory.TheoRelease">
            <summary>
            Represents a product or library release
            </summary>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoRelease.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation
            </summary>
            <returns>The string representation</returns>
        </member>
        <member name="T:Theobald.Common.VersionHistory.TheoVersion">
            <summary>
            Represents a product or kernel version
            </summary>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoVersion.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation
            </summary>
            <returns>The string representation</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoVersion.ToString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation and appends the branch name.
            </summary>
            <param name="branchName">Branch name to append</param>
            <returns>The string representation containing the branch name.</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoVersion.TryParse(System.String,Theobald.Common.VersionHistory.TheoVersion@)">
            <summary>
             Tries to convert the string representation of a version number
             to its TheoVersion equivalent
            </summary>
            <param name="value">The string representation</param>
            <param name="version">The converted TheoVersion</param>
            <returns>True if the conversion succeeded; false otherwise</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoVersion.Compare(Theobald.Common.VersionHistory.TheoVersion,Theobald.Common.VersionHistory.TheoVersion)">
            <summary>
            Compares two specified TheoVersion objects and returns an integer that
            indicates their relationship to one another in the sort order.
            </summary>
            <param name="versionA">The first TheoVersion object</param>
            <param name="versionB">The second TheoVersion object</param>
            <returns>A 32-bit signed integer indicating the temporal relationship between the two comparands.
            Less than zero: versionA is older than versionB.
            Zero: versionA equals versionB. 
            Greater than zero: versionA is newer than versionB.</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoVersion.CompareTo(Theobald.Common.VersionHistory.TheoVersion)">
            <summary>
            Compares this instance to the specified TheoVersion object and returns an integer that
            indicates their relationship to one another in the sort order.
            </summary>
            <param name="other">The version to compare with this instance</param>
            <returns>A 32-bit signed integer indicating the temporal relationship between the two comparands.
            Less than zero: this instance is older than the other.
            Zero: this instance equals the other. 
            Greater than zero: this instance is newer than the other</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoVersion.Equals(System.Object)">
            <summary>
            Determines whether this instance is equal to the specified System.Object
            </summary>
            <param name="obj">The System.Object to compare with this instance</param>
            <returns>True if this instance is equal to the specified System.Object; false otherwise</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoVersion.GetHashCode">
            <summary>
            Returns the hash code for this instance
            </summary>
            <returns>A 32-bit signed integer hash code</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoVersion.op_Equality(Theobald.Common.VersionHistory.TheoVersion,Theobald.Common.VersionHistory.TheoVersion)">
            <summary>
            Determines if two versions are equal
            </summary>
            <param name="versionA">The first version</param>
            <param name="versionB">The second version</param>
            <returns>True if the specified versions are equal; false otherwise</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoVersion.op_Inequality(Theobald.Common.VersionHistory.TheoVersion,Theobald.Common.VersionHistory.TheoVersion)">
            <summary>
            Determines if two versions are not equal
            </summary>
            <param name="versionA">The first version</param>
            <param name="versionB">The second version</param>
            <returns>True if the specified versions are not equal; false otherwise</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoVersion.op_LessThan(Theobald.Common.VersionHistory.TheoVersion,Theobald.Common.VersionHistory.TheoVersion)">
            <summary>
            Determines if one version is newer than another version
            </summary>
            <param name="versionA">The first version</param>
            <param name="versionB">The second version</param>
            <returns>True if the first version is newer than the second version; false otherwise</returns>
        </member>
        <member name="M:Theobald.Common.VersionHistory.TheoVersion.op_GreaterThan(Theobald.Common.VersionHistory.TheoVersion,Theobald.Common.VersionHistory.TheoVersion)">
            <summary>
            Determines if one version is older than another version
            </summary>
            <param name="versionA">The first version</param>
            <param name="versionB">The second version</param>
            <returns>True if the first version is older than the second version; false otherwise</returns>
        </member>
        <member name="T:Theobald.Common.VersionHistory.UpdatePriority">
            <summary>
            Enumeration of update priority values.
            </summary>
        </member>
        <member name="F:Theobald.Common.VersionHistory.UpdatePriority.None">
            <summary>
            Undefined priority
            </summary>
        </member>
        <member name="F:Theobald.Common.VersionHistory.UpdatePriority.Low">
            <summary>
            Low priority: On the customer's side action is only required, if the customer has requested this bug fix or if advised by the support team
            </summary>
        </member>
        <member name="F:Theobald.Common.VersionHistory.UpdatePriority.Medium">
            <summary>
            Medium priority: It is recommended to install this version as a regular update
            </summary>
        </member>
        <member name="F:Theobald.Common.VersionHistory.UpdatePriority.High">
            <summary>
            High priority: Data loss is likely to occur or a security risk was found and fixed
            </summary>
        </member>
        <member name="M:Theobald.Common.WriteBuffer.SplitOrCollect(System.ArraySegment{System.Byte})">
            <summary>
            Returns chunks of the buffer's size by splitting/collecting/combining
            the <paramref name="bytes"/> of multiple calls.
            </summary>
        </member>
        <member name="M:Theobald.Common.WriteBuffer.Flush">
            <summary>
            Returns the saved bytes that didn't make a full chunk yet.
            </summary>
        </member>
        <member name="T:Theobald.Json.IJsonSerializable">
             <summary>
             Interface for classes, which support JSON serialization.
            
             The basic idea is to write explicit serialization and
             deserialization methods for each class which
             supports JSON serialization.
            
             This approach allows to implement individual processing
             during serialization/deserialization (e. g.  to support
             multiple serialized versions etc.) which is not possible
             using generic serialization approaches.
             Im contrast to generic approaches, it requires neither
             reflection nor a code generator.
            
             This approach requires the programmer to explicitly write
             serialization code, which hopefully makes him or her
             think about the class design.
             It should be easy to write serialization code in most cases.
             If it is not, that might be an indicator for bad class design.
             </summary>
        </member>
        <member name="M:Theobald.Json.IJsonSerializable.ReadJson(Theobald.Json.JsonReader)">
            <summary>
            Deserializes this instance from JSON
            </summary>
            <returns>returns true when there was an object and false if not. This could happen if it is called for an empty Array</returns>
        </member>
        <member name="M:Theobald.Json.IJsonSerializable.WriteJson(Theobald.Json.JsonWriter)">
            <summary>
            Serializes this instance to JSON
            </summary>
        </member>
        <member name="T:Theobald.Json.JsonException">
            <summary>
            Represents an exception for JSON serialization
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Theobald.Json.JsonException"/> class that is empty.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the JsonException class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Theobald.Json.JsonException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the JsonException class with a specified error message
            and reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">
                The exception that is the cause of the current exception, or a null reference
                (Nothing in Visual Basic) if no inner exception is specified.
            </param>
        </member>
        <member name="T:Theobald.Json.JsonReadResult">
            <summary>
            The tokens which make the parser stop reading
            </summary>
        </member>
        <member name="T:Theobald.Json.JsonReader">
            <summary>
            A lightweight JSON parser
            </summary>
        </member>
        <member name="F:Theobald.Json.JsonReader.textReader">
            <summary>
            JSON is character-based, we need to read text
            </summary>
        </member>
        <member name="F:Theobald.Json.JsonReader.tokenBuilder">
            <summary>
            Buffer for variable-length tokens
            </summary>
        </member>
        <member name="F:Theobald.Json.JsonReader.tokenBuffer">
            <summary>
            Buffer for fixed-length tokens
            </summary>
        </member>
        <member name="F:Theobald.Json.JsonReader.readResult">
            <summary>
            Result of the last read operation
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.AssertNotEof">
            <summary>
            Throws an exception if the end of the input
            has already been reached
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadCharacter">
            <summary>
            Reads a character from the input
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.SkipWhitespace">
            <summary>
            Keeps reading characters from the input
            until a non-whitespace character has been read
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ParseHexDigit(System.Char)">
            <summary>
            Converts a hexadecimal digit to its numeric value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Theobald.Json.JsonReader.ParseEscapeSequence">
            <summary>
            Reads 1-5 characters,
            interprets them as escape sequence (without leading backspace)
            and appends the unescaped value to the variable-length token buffer
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ParseString">
            <summary>
            Reads characters until a double quote is encountered.
            Reads the character following the double quote.
            Interprets characters before the double quote as string
            and stores them in the variable-length token buffer.
            Performs unescaping if necessary.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadDigits">
            <summary>
            Reads decimal digits until a non-digit character has been read
            and appends them to the variable-length token buffer
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadNumberInternal">
            <summary>
            Reads characters, interprets them as a number
            and stores them in the variable-length token buffer.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ParseTrue">
            <summary>
            Reads 3 characters and throws an exception if
            they do not match the string 'rue'
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ParseFalse">
            <summary>
            Reads 4 characters and throws an exception if
            they do not match the string 'alse'
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ParseNull">
            <summary>
            Reads 3 characters and throws an exception if
            they do not match the string 'ull'
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.Read">
            <summary>
            Reads the next token and stores it
            in the variable-length token buffer, if necessary
            </summary>
            <returns>The kind of token which has been read</returns>
        </member>
        <member name="M:Theobald.Json.JsonReader.Skip">
            <summary>
            Skips a token
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.SkipObject">
            <summary>
            Skips an object.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.SkipArray">
            <summary>
            Skips an array.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.SkipComma">
            <summary>
            Reads the next member or element
            skipping eventual commas.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadObjectStart">
            <summary>
            Reads the next token and throws an exception
            if it is not the beginning of an object
            </summary>
            <returns>Returns true if there was an Object Start and false if an array ends or EOF</returns>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadObjectEnd">
            <summary>
            Reads the next token and throws an exception
            if it is not the end of an object
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadArrayStart">
            <summary>
            Reads the next token and throws an exception
            if it is not the beginning of an array
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadArrayEnd">
            <summary>
            Reads the next token and throws an exception
            if it is not the end of an array
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadName">
            <summary>
            Reads the name of the next member of the current object
            and returns its value, or null if the end the object has been reached.
            Throws an exception otherwise.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadString">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it is not a string or null value.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadStrings">
            <summary>
            Tries to deserialize an array of strings
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadInt32">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it is not a number which can
            be interpreted as <code>System.Int32</code>.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadNumber">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it is not a valid number
            defined by the JSON standard.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadBooleans(System.Action{System.Nullable{System.Boolean}})">
            <summary>
            Reads an array of booleans.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadStrings(System.Action{System.String})">
            <summary>
            Reads an array of strings.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadNumbers(System.Action{System.Nullable{Theobald.Common.Number}})">
            <summary>
            Reads an array of numbers.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadInt32s">
            <summary>
            Tries to deserialize an array of numbers
            Throws an exception if a number cannot
            be interpreted as <see cref="T:System.Int32" />.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadInt64">
            <summary>
            Reads the next token and returns its value.
            </summary>
            <exception cref="T:System.OverflowException">
            Thrown if the value is either too large
            or too small for <see cref="T:System.Int64"/>
            </exception>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadUInt16">
            <summary>
            Reads the next token and returns its value.
            </summary>
            <exception cref="T:System.OverflowException">
            Thrown if the value is either too large
            or too small for <see cref="T:System.UInt16"/>
            </exception>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadDecimal">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it is not a string which can
            be interpreted as <see cref="T:System.Decimal" />.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadDecimals">
            <summary>
            Tries to deserialize an array of decimals
            Throws an exception if a number cannot
            be interpreted as <see cref="T:System.Decimal" />.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadDouble">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it is not a string which can
            be interpreted as <see cref="T:System.Double" />.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadDoubles">
            <summary>
            Tries to deserialize an array of doubles
            Throws an exception if a number cannot
            be interpreted as <see cref="T:System.Double" />.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadBoolean">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it is not a boolean.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadBooleans">
            <summary>
            Tries to deserialize an array of booleans
            Throws an exception if a number cannot
            be interpreted as <see cref="T:System.Boolean" />.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadTimestamp">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it cannot be interpreted as 
            an IS0 8601 timestamp, precision is milliseconds.
            <example>19840523T133337.425Z</example>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadDuration">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it cannot be interpreted as 
            an IS0 8601 time duration, precision is milliseconds.
            <example>PT23H42M13.337S</example>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadDate">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it cannot be interpreted as a date in format yyyy-MM-dd.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadTime">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it cannot be interpreted as a time in format HH:mm:ss.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadBytes">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it cannot be interpreted as a byte array
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadEnum``1">
            <summary>
            Reads the next token and returns its value.
            Throws an exception if it cannot be interpreted as
            the specified enum.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadEnums``1">
            <summary>
            Tries to deserialize an array of strings
            Throws an exception if a string cannot
            be interpreted as the given enum.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadEnums``1(System.Boolean)">
            <summary>
            Tries to deserialize an array of strings.
            <param name="ignoreUnknownStrings">
            Boolean indicating whether to ignore unknown string literals or not.
            </param>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadObject``1(System.Func{``0})">
            <summary>
            Tries to deserialize an object
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadObject``1">
            <summary>
            Tries to deserialize an object
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.AddObjects``1(System.Func{``0},System.Collections.Generic.ICollection{``0})">
            <summary>
            Tries to deserialize an array of objects
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadArray(System.Func{Theobald.Json.JsonReader,System.Boolean})">
            <summary>
            Tries to deserialize an array of objects
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.AddObjects``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Tries to deserialize an array of objects
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadObjects``1(System.Func{``0})">
            <summary>
            Tries to deserialize an array of objects
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadObjects``1">
            <summary>
            Tries to deserialize an array of objects
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadJson(Theobald.Json.IJsonSerializable,System.String)">
            <summary>
            Tries to deserialize an object
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.FromJson``1(System.String)">
            <summary>
            Tries to deserialize an object
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.ReadFile(Theobald.Json.IJsonSerializable,System.String)">
            <summary>
            Deserializes an object which has been stored to a file
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonReader.FromFile``1(System.String)">
            <summary>
            Tries to deserialize an object
            </summary>
        </member>
        <member name="T:Theobald.Json.JsonSerializableObject">
            <summary>
            Can be used as base class for serializable objects.
            Supports inheritance.
            For reference code see AbapColumn and TableField in Theobald.Extractors
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonSerializableObject.ReadJsonProperty(Theobald.Json.JsonReader,System.String)">
            <summary>
            Reads the value of the JSON member at the <paramref name="reader"/>'s
            position, and sets the corresponding property (if any) based on
            the member's name
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonSerializableObject.WriteJsonFields(Theobald.Json.JsonWriter)">
            <summary>
            Serializes all required private fields using the <paramref name="writer"/>
            </summary>
        </member>
        <member name="T:Theobald.Json.JsonWriter">
            <summary>
            A lightweight, pretty-printing JSON generator
            </summary>
            <remarks>JSON spec can be found here: http://json.org/ </remarks>
        </member>
        <member name="F:Theobald.Json.JsonWriter.indentation">
             <summary>
             Our generated JSON should be nice to read for humans,
             (that makes debugging a lot easier)
             therefore we need newlines and indentation.
             We use a statically defined block of characters
             as a source for whitespace.
             </summary>
             <remarks>
             This block must be large enough to support
             the current level of indentation.
             It therefore implicitly limits the
             maximum level of indentation.
            
             ATTENTION!
             Please consider redesigning your nested structure
             before you increase the size of this array!
             23 levels of nesting should be PLENTY for
             all sanely designed structures!
             </remarks>
        </member>
        <member name="F:Theobald.Json.JsonWriter.textWriter">
            <summary>
            JSON is character-based, we need to write text
            </summary>
        </member>
        <member name="F:Theobald.Json.JsonWriter.indentationLevel">
            <summary>
            The current level of indentation.
            </summary>
        </member>
        <member name="F:Theobald.Json.JsonWriter.isCommaRequired">
            <summary>
            If this flag is set, a comma will be written at
            the end of a line
            </summary>
        </member>
        <member name="F:Theobald.Json.JsonWriter.isPrettyPrintEnabled">
            <summary>
            If this flag is set, the json string will be prettyprinted.
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteNewLine">
            <summary>
            Writes a new line and adds whitespace
            according to the current indentation settings
            <remarks>
            If this method throws an ArgumentOutOfRangeException,
            you have exceeded the maximum indentation level.
            That probably means you have written an infinite loop
            or you are trying to serialize an insanely nested structure.
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteNewMemberOrElement">
            <summary>
            This method must be called before writing a new member to an object
            or  a new element to an array
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteObjectStart">
            <summary>
            Starts a new object
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteObjectEnd">
            <summary>
            Finishes the current object
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteArrayStart">
            <summary>
            Starts a new array
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteArrayEnd">
            <summary>
            Finishes an array
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteArray``1(System.String,System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="values"/> is <code>null</code> or empty.
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteString(System.String)">
            <summary>
            Writes a string value and performs escaping, if required
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteNumber(System.Int32)">
            <summary>
            Writes a number value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteName(System.String)">
            <summary>
            Writes a name of a member
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteNull(System.String)">
            <summary>
            Writes a member to an object with an explicit value of <code>null</code>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.String)">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="value"/> is <code>null</code>
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="values"/> is <code>null</code> or empty.
            All elements of the enumerable are serialized (<code>null</code>s, too).
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Nullable{System.Int32})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Nullable{System.Int64})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Nullable{System.UInt16})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteTheoNumber(System.String,System.Nullable{Theobald.Common.Number})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Nullable{System.Double})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Nullable{System.Decimal})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Nullable{System.UInt64})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Nullable{System.Int16})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Nullable{System.Byte})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="values"/> is <code>null</code> or empty
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Nullable{System.Boolean})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Byte[])">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="value"/> is <code>null</code>
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Enum)">
            <summary>
            Writes a member to an object
            </summary>
            <remarks>
            Member is omitted if <code>value</code>
            is <code>null</code></remarks>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteEnums``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes an enumerable of enums as member to an object
            <remarks>
            Member is omitted if <paramref name="values"/> is <code>null</code> or empty
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,Theobald.Json.IJsonSerializable)">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="value"/> is <code>null</code>
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.Write(System.String,System.Collections.Generic.IEnumerable{Theobald.Json.IJsonSerializable})">
            <summary>
            Writes a member to an object
            <remarks>
            Member is omitted if <paramref name="values"/> is <code>null</code> or empty.
            All elements of the enumerable are serialized (<code>null</code>s, too).
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteTimestamp(System.String,System.Nullable{System.DateTime})">
            <summary>
            Writes an IS0 8601 timestamp, precision is milliseconds.
            <example>19840523T133337.425Z</example>
            <remarks>
            This format is incompatible with the JavaScript Date object,
            but compatible with Temporal.Instant https://tc39.es/proposal-temporal/docs/instant.html
            
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteDuration(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Writes an IS0 8601 duration without date, precision is milliseconds.
            <example>PT23H42M13.337S</example>
            <remarks>
            This format is incompatible with the JavaScript Date object,
            but compatible with Temporal.Duration https://tc39.es/proposal-temporal/docs/duration.html
            
            Member is omitted if <paramref name="nullable"/> has no value
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteDate(System.String,System.Nullable{System.DateTime})">
            <summary>
            Writes a Date (yyyy-MM-dd) member to an object.
            This format is compatible with both the JavaScript Date object and Temporal.PlainDate
            https://tc39.es/proposal-temporal/docs/plaindate.html
            </summary>
        </member>
        <member name="M:Theobald.Json.JsonWriter.WriteTime(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Writes a Time (HH:mm:ss) member to an object, precision is seconds.
            This format is incompatible with the JavaScript Date object,
            but compatible with Temporal.PlainTime https://tc39.es/proposal-temporal/docs/plaintime.html
            </summary>
        </member>
        <member name="T:Theobald.Logging.ILog">
            <summary>
            Defines basic methods for logging.
            <remarks>
                Use <see cref="M:Theobald.Logging.ILogExtensions.WithSource(Theobald.Logging.ILog,System.String@)"/> to add a log source to an <see cref="T:Theobald.Logging.ILog"/> instance,
                and <see cref="P:Theobald.Logging.LogWithSource.WithoutSource"/> to remove it.
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Logging.ILog.Log(System.DateTime@,System.String@,Theobald.Logging.LogLevel@,System.String@)">
            <summary>
            Appends a log entry for everything but exceptions.
            <remarks>
                Typically not to be used directly. Use <see cref="M:Theobald.Logging.ILogExtensions.WithSource(Theobald.Logging.ILog,System.String@)"/> to add a log source first.
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Logging.ILog.Log(System.String@,System.Exception@,System.String@)">
            <summary>
            Appends a log entry for an exception.
            <remarks>
                Typically not to be used directly. Use <see cref="M:Theobald.Logging.ILogExtensions.WithSource(Theobald.Logging.ILog,System.String@)"/> to add a log source first.
            </remarks>
            </summary>
        </member>
        <member name="M:Theobald.Logging.ILog.Start(System.DateTime@)">
            <summary>
            Starts the log.
            </summary>
            <param name="startedAt">
                The timestamp, that identifies the log,
                and represents the base for relative timestamps of its entries.
            </param>
        </member>
        <member name="M:Theobald.Logging.ILogExtensions.StartNow(Theobald.Logging.ILog)">
            <summary>
            Starts the log now.
            <seealso cref="M:Theobald.Logging.ILog.Start(System.DateTime@)"/>
            </summary>
        </member>
        <member name="M:Theobald.Logging.ILogExtensions.WithSource(Theobald.Logging.ILog,System.String@)">
            <summary>
            Adds a log source to the basic <paramref name="log"/>.
            <seealso cref="P:Theobald.Logging.LogWithSource.WithoutSource"/>
            </summary>
        </member>
        <member name="T:Theobald.Logging.LogLevel">
            <summary>
            Specifies the severity of log entries.
            </summary>
        </member>
        <member name="F:Theobald.Logging.LogLevel.None">
            <summary>
            The severity of the log entry is not defined.
            </summary>
        </member>
        <member name="F:Theobald.Logging.LogLevel.Debug">
            <summary>
            The log entry contains detailed information for debugging purposes.
            </summary>
        </member>
        <member name="F:Theobald.Logging.LogLevel.Info">
            <summary>
            The log entry contains general information.
            </summary>
        </member>
        <member name="F:Theobald.Logging.LogLevel.Warning">
            <summary>
            The log entry contains information about potential problems.
            </summary>
        </member>
        <member name="F:Theobald.Logging.LogLevel.Error">
            <summary>
            The log entry contains information about errors.
            </summary>
        </member>
        <member name="T:Theobald.Logging.LogEntry">
            <summary>
            Represents a log entry
            </summary>
        </member>
        <member name="P:Theobald.Logging.LogEntry.StartedAt">
            <summary>
            Gets the absolute time at which logging of a series
            of events (e. g. an extraction) has started
            </summary>
        </member>
        <member name="P:Theobald.Logging.LogEntry.Elapsed">
            <summary>
            Gets the relative time offset of this entry
            </summary>
        </member>
        <member name="P:Theobald.Logging.LogEntry.Timestamp">
            <summary>
            Gets the absolute timestamp of this entry
            </summary>
        </member>
        <member name="P:Theobald.Logging.LogEntry.Level">
            <summary>
            Gets the severity of the log entry
            </summary>
        </member>
        <member name="P:Theobald.Logging.LogEntry.Source">
            <summary>
            Gets the source of the log entry
            </summary>
        </member>
        <member name="P:Theobald.Logging.LogEntry.Message">
            <summary>
            Gets the text of the log entry
            </summary>
        </member>
        <member name="M:Theobald.Logging.LogEntry.ToString">
            <summary>
            Serializes the entry
            </summary>
        </member>
        <member name="M:Theobald.Logging.LogEntry.Parse(System.ArraySegment{System.Char},System.DateTime)">
            <summary>
            Deserializes an  entry
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="F:Theobald.Logging.LoggerBase.appendLock">
            <summary>
            We want to keep multi-line messages / stack traces together in one block,
            and don't want our lines to get mixed up by parallel calls.
            </summary>
        </member>
        <member name="M:Theobald.Logging.LoggerBase.MillisecondsFloorUtc(System.DateTime@)">
            <summary>
            Cuts off all values that are more precise than milliseconds
            <exception cref="T:System.ArgumentOutOfRangeException">
                If non-UTC. <see cref="T:System.DateTime"/> does not contain a time zone,
                which causes a lot of problems when calculating with
                <see cref="F:System.DateTimeKind.Local"/>.
            </exception>
            </summary>
        </member>
        <member name="M:Theobald.Logging.LoggerBase.SplitMessage(System.String,System.String,System.DateTime,Theobald.Logging.LogLevel)">
            <summary>
            Creates a separate <see cref="T:Theobald.Logging.LogEntry"/> for each line of <paramref name="message"/>
            </summary>
        </member>
        <member name="M:Theobald.Logging.LoggerMultiSplitting.NewEntry(System.DateTime@,Theobald.Logging.LogLevel@,System.String@,System.String@)">
            <summary>
            Automatically starts a new log after 24h.
            This requires log entries to arrive ordered by timestamp.
            </summary>
        </member>
        <member name="M:Theobald.Logging.LoggerTextFile.StartWithNewFile">
            <summary>
            Increases the current timestamp by one millisecond
            until it results in a new log file
            </summary>
        </member>
        <member name="T:Theobald.Logging.LogWithSource">
            <summary>
            An <see cref="T:Theobald.Logging.ILog"/> instance with a defined log source.
            The log source is just an arbitrary string identifier that will appear in each log entry.
            <remarks>
                Use <see cref="M:Theobald.Logging.ILogExtensions.WithSource(Theobald.Logging.ILog,System.String@)"/> to add a log source to an <see cref="T:Theobald.Logging.ILog"/> instance,
                and <see cref="P:Theobald.Logging.LogWithSource.WithoutSource"/> to remove it.
            </remarks>
            </summary>
        </member>
        <member name="P:Theobald.Logging.LogWithSource.WithoutSource">
            <summary>
            Returns the basic log with no source associated.
            <seealso cref="M:Theobald.Logging.ILogExtensions.WithSource(Theobald.Logging.ILog,System.String@)"/>
            </summary>
        </member>
        <member name="M:Theobald.Logging.LogWithSource.#ctor(Theobald.Logging.ILog@,System.String@)">
            <summary>
            Initializes a new instance. Consider using <see cref="M:Theobald.Logging.ILogExtensions.WithSource(Theobald.Logging.ILog,System.String@)"/> instead.
            </summary>
        </member>
        <member name="M:Theobald.Logging.LogWithSource.FormatAndLog(Theobald.Logging.LogLevel@,System.String@,System.Object[])">
            <summary>
            Applies <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> before appending the log entry.
            </summary>
        </member>
        <member name="M:Theobald.Logging.LogWithSource.Debug(System.FormattableString@)">
            <inheritdoc cref="F:Theobald.Logging.LogLevel.Debug"/>
        </member>
        <member name="M:Theobald.Logging.LogWithSource.Inform(System.FormattableString@)">
            <inheritdoc cref="F:Theobald.Logging.LogLevel.Info"/>
        </member>
        <member name="M:Theobald.Logging.LogWithSource.Warn(System.FormattableString@)">
            <inheritdoc cref="F:Theobald.Logging.LogLevel.Warning"/>
        </member>
        <member name="M:Theobald.Logging.LogWithSource.Err(System.FormattableString@)">
            <inheritdoc cref="F:Theobald.Logging.LogLevel.Error"/>
        </member>
        <member name="M:Theobald.Logging.LogWithSource.Err(System.FormattableString@,System.Exception)">
            <inheritdoc cref="F:Theobald.Logging.LogLevel.Error"/>
        </member>
        <member name="M:Theobald.Logging.LogWithSource.Err(System.Exception)">
            <inheritdoc cref="F:Theobald.Logging.LogLevel.Error"/>
        </member>
        <member name="T:Theobald.Logging.NullLogger">
            <summary>
            A logger that spirits away all entries into the endless void of nothingness.
            </summary>
        </member>
        <member name="M:Theobald.Logging.NullLogger.Log(System.DateTime@,System.String@,Theobald.Logging.LogLevel@,System.String@)">
            <summary>
            Everything that is passed to this method will be ignored.
            </summary>
        </member>
        <member name="M:Theobald.Logging.NullLogger.Log(System.String@,System.Exception@,System.String@)">
            <summary>
            Don't like exceptions? Just pass them in here and they will be gone.
            </summary>
        </member>
        <member name="M:Theobald.Logging.NullLogger.Start(System.DateTime@)">
            <summary>
            This method is irrelevant.
            </summary>
        </member>
        <member name="M:Theobald.SyntacticSugar.ObjectExtensions.ThrowIfNull(System.Object,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentNullException"/>
            if <paramref name="value"/> is <code>null</code>
            </summary>
        </member>
        <member name="M:Theobald.SyntacticSugar.ObjectExtensions.GetOrThrowIfNull``1(``0,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentNullException"/>
            if <paramref name="value"/> is <code>null</code>
            or returns <paramref name="value"/>
            </summary>
        </member>
        <member name="M:Theobald.SyntacticSugar.ObjectExtensions.IntoEnumerable``1(``0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <typeparam name="T"></typeparam>
            <returns>An Enumerable, which only yields this one item.</returns>
        </member>
        <member name="M:Theobald.SyntacticSugar.StringExtensions.ThrowIfNullOrWhiteSpace(System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/>
            if <paramref name="value"/> is <code>null</code> or whitespace.
            </summary>
        </member>
        <member name="M:Theobald.SyntacticSugar.StringExtensions.ReplaceWith(System.String,System.Object[])">
            <summary>
            Performs <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>
            if <paramref name="value"/> is not <code>null</code> or whitespace
            </summary>
        </member>
        <member name="T:Theobald.Win32.ConsoleApi2">
            <summary>
            consoleapi2.h
            </summary>
        </member>
        <member name="T:Theobald.Win32.HandleApi">
            <summary>
            handleapi.h
            </summary>
        </member>
        <member name="T:Theobald.Win32.MinWinBase">
            <summary>
            minwinbase.h
            </summary>
        </member>
        <member name="T:Theobald.Win32.ProcessEnv">
            <summary>
            ProcessEnv.h
            </summary>
        </member>
        <member name="T:Theobald.Win32.ProcessThreadsApi">
            <summary>
            processthreadsapi.h
            </summary>
        </member>
        <member name="T:Theobald.Win32.WinBase">
            <summary>
            WinBase.h
            </summary>
        </member>
        <member name="F:Theobald.Win32.WinBase.ProcessCreationFlags.CREATE_NO_WINDOW">
            <summary>
            The process is a console application that is being run without a console window. Therefore, the console handle for the application is not set.
            This flag is ignored if the application is not a console application, or if it is used with either CREATE_NEW_CONSOLE or DETACHED_PROCESS.
            </summary>
        </member>
        <member name="T:Theobald.Win32.WinError">
            <summary>
            winerror.h
            </summary>
        </member>
        <member name="F:Theobald.Win32.WinError.ErrorCode.ERROR_TIMEOUT">
            <summary>
            This operation returned because the timeout period expired.
            </summary>
        </member>
        <member name="T:Theobald.Win32.WinNt">
            <summary>
            winnt.h
            </summary>
        </member>
        <member name="T:Theobald.Win32.WinUser">
            <summary>
             WinUser.h
            </summary>
        </member>
        <member name="M:Theobald.Win32.WaitRegistration.Add(System.Threading.WaitHandle@,System.Action)">
            <summary>
            Monitors the wait handle and performs an action, when the handle receives a signal
            </summary>
        </member>
    </members>
</doc>
